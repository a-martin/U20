summary(fitNumDem)
fitAdjNum <- MCMCglmm(fixed=fixed, random=random, prior=prior,
family="categorical", data = testAdjNum, saveX=TRUE, saveZ=TRUE, verbose=FALSE);
summary(fitAdjNum)
install.packages("knitr")
install.packages("yaml")
install.packages("htmltools")
install.packages("catools")
install.packages("coaols")
install.packages("caTools")
install.packages("bitops")
install.packages("rmarkdown")
---
title: "U20 English -- reported in Culbertson & Adger (2014)"
output:
html_notebook: default
html_document: default
---
## Preliminaries
```{r}
library(ggplot2)
library(colorspace)
library(lme4)
library(plyr)
```
## Read in the data
Note that for MTurk output files, there can be multiple workers' data in a single file. This makes it look a bit different from data collected via blake, where there is always just a single participant's data in each file.
```{r}
files <- list.files("data",pattern="*.csv",recursive=FALSE);
mturkData <- NULL;
for (fi in files) {
di <- read.csv(paste("data",fi,sep="/"), encoding="UTF-8", quote = "", header=FALSE);
for (j in 2:nrow(di)) {	# skip first row (this is the header for the file)
workerIdj <- NA;
sexj <- NA;
acceptTimej <- NA;
submitTimej <- NA;
conditionj <- NA;
listj <- NA;
trialsj <- c();
# process data in the current row (a single participant)
# looking back to header row to find which columns contain the relevant info
for (k in 1:ncol(di)) {
if (grepl("WorkerId",di[1,k])) { workerIdj <- as.character(di[j,k]); }
if (grepl("^(fe)male$",di[j,k])) { sexj <- as.character(di[j,k]); }
if (grepl("AcceptTime",di[1,k])) { acceptTimej <- as.character(di[j,k]); }
if (grepl("SubmitTime",di[1,k])) { submitTimej <- as.character(di[j,k]); }
if (grepl("^condition",di[j,k])) { conditionj <- as.character(di[j,k]); }
if (grepl("^list",di[j,k])) { listj <- as.character(di[j,k]); }
if (grepl("^((train)|(test))Trial",di[j,k])) { trialsj <- c(trialsj,as.character(di[j,k])); }
}
# make data frame for current row
mturkDataj <- data.frame(
ID=workerIdj,
sex=sexj,
acceptTime=acceptTimej,
submitTime=submitTimej,
condition=conditionj,
list=listj,
trials=trialsj );
# accumulate data across rows
if (is.null(mturkData)) { mturkData <- mturkDataj; }
else { mturkData <- rbind(mturkData,mturkDataj); }
}
}
```
Create a new column for training vs. testing phase, and then get just the testing lines
```{r}
mturkData$phase <- ifelse(grepl("trainTrial",mturkData$trial),"train","test");
test <- subset(mturkData, phase=="test");
```
Then need to parse the testing trials into their various parts.
```{r}
# parse train and test trial information
test$trial <- sapply(as.character(test$trials), function(x) { strsplit(x,"_")[[1]][1] });
test$type <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][2] });
test$text <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][3] });
test$choice1 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][4] });
test$choice2 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][5] });
test$choice3 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][6] });
test$choice4 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][7] });
test$correctChoice <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][8] });
test$oldNew <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][9] });
test$response <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][10] });
```
Then create a new column to read radio button responses as choices 1-4
```{r}
# map responses to the same format as correct choice
test$choice <- test$response;
test$choice <- ifelse(	test$response=="radio5","1",
ifelse( test$response=="radio6","2",
ifelse( test$response=="radio7","3",
ifelse( test$response=="radio8","4",NA))));
```
Create a column with information specifying conditions as "NAdjNum","NNumDem","NAdjDem" (currently, the condition is an old label from the original design, and list has the condition information).
```{r}
test$condition <- NA
test[test$list %in% c("list_A_NumAdj","list_B_NumAdj"),]$condition <- "NAdjNum"
test[test$list %in% c("list_A_DemNum","list_B_DemNum"),]$condition <- "NNumDem"
test[test$list %in% c("list_A_DemAdj","list_B_DemAdj","list_A","list_B"),]$condition <- "NAdjDem"
```
Now, a series of functions, etc used to determine which button corresponds to which type of order, according to which class of modifier is the "inner" and "outer" for the condition.
First, a function that takes a string and outputs its order:
```{r}
stringToOrder <- function(string,inner,outer,nouns) {
words <- strsplit(string," ")
if (length(words[[1]])==2 || words=="-----") { order <- "twoWords"}
else {
if (words[[1]][1] %in% nouns) {
if (words[[1]][2] %in% inner) { order <- "NInnerOuter"}
else {order <- "NOuterInner"}
}
else {
if (words[[1]][1] %in% inner) { order <- "InnerOuterN"}
else {order <- "OuterInnerN"}
}
}
order
}
```
Then a function to find nouns, and inner and outer modifiers:
```{r}
findLexicon <- function(data_row) {
# all possible lexical items
dems <- c("that","this","these","those");
nouns <-c("banana","box","chair","couch","dart","handbag","key","leaf","pear","pineapple",
"ribbon","shirt","shovel","suitcase","vase","bowl","car","cherry","cow","duck",
"hat","horse","lamp","pig","pillow","pitcher","scarf","shoe","spatula","tray",
"bananas","boxes","chairs","couches","darts","handbags","keys","leaves","pears",
"pineapples","ribbons","shirts","shovels","suitcases","vases","bowls","cars",
"cherries","cows","ducks","hats","horses","lamps","pigs","pillows","pitchers",
"scarves","shoes","spatulas","trays");
adjs <- c("purple","furry","spotted","wooden","green","orange","dirty","striped","stone","blue");
nums <- c("two","three","six","seven","nine","one","four","five","eight","ten");
# set default inner and outer
inner <- adjs;
outer <- dems;
# change if necessary based on condition
if (data_row$condition=="NNumDem") { inner <- nums; }
if (data_row$condition=="NAdjNum") { outer <- nums; }
lexicon <- list(nouns=nouns,inner=inner,outer=outer)
}
```
Now the function for looping over the data:
```{r}
labelChoices <- function(data) {
data$choice1_order <- NA; data$choice2_order <- NA; data$choice3_order <- NA; data$choice4_order <- NA
data$choice_order <- NA
# loop over all rows in the data
# find lexicon, then output choice orders for each option
for (i in 1:nrow(data)) {
# find lexicon, including inner and outer modifiers for this row of data
lexicon = findLexicon(data[i,])
# split the words from each choice apart
data[i,]$choice1_order <- stringToOrder(data[i,]$choice1,lexicon$inner,lexicon$outer,lexicon$nouns)
data[i,]$choice2_order <- stringToOrder(data[i,]$choice2,lexicon$inner,lexicon$outer,lexicon$nouns)
data[i,]$choice3_order <- stringToOrder(data[i,]$choice3,lexicon$inner,lexicon$outer,lexicon$nouns)
data[i,]$choice4_order <- stringToOrder(data[i,]$choice4,lexicon$inner,lexicon$outer,lexicon$nouns)
}
# label the order of participant's response choice
data[data$choice=="1",]$choice_order <- data[data$choice=="1",]$choice1_order
data[data$choice=="2",]$choice_order <- data[data$choice=="2",]$choice2_order
data[data$choice=="3",]$choice_order <- data[data$choice=="3",]$choice3_order
data[data$choice=="4",]$choice_order <- data[data$choice=="4",]$choice4_order
# return the labelled dataframe
data
}
```
And finally, run the function:
```{r}
test = labelChoices(test)
library(ggplot2)
library(colorspace)
library(lme4)
library(plyr)
install.packages("rmarkdown")
library(ggplot2)
library(colorspace)
library(lme4)
library(plyr)
require(rmarkdown)
files <- list.files("data",pattern="*.csv",recursive=FALSE);
mturkData <- NULL;
install.packages('knitr')
install.packages("knitr")
for (fi in files) {
di <- read.csv(paste("data",fi,sep="/"), encoding="UTF-8", quote = "", header=FALSE);
for (j in 2:nrow(di)) {	# skip first row (this is the header for the file)
workerIdj <- NA;
sexj <- NA;
acceptTimej <- NA;
submitTimej <- NA;
conditionj <- NA;
listj <- NA;
trialsj <- c();
# process data in the current row (a single participant)
# looking back to header row to find which columns contain the relevant info
for (k in 1:ncol(di)) {
if (grepl("WorkerId",di[1,k])) { workerIdj <- as.character(di[j,k]); }
if (grepl("^(fe)male$",di[j,k])) { sexj <- as.character(di[j,k]); }
if (grepl("AcceptTime",di[1,k])) { acceptTimej <- as.character(di[j,k]); }
if (grepl("SubmitTime",di[1,k])) { submitTimej <- as.character(di[j,k]); }
if (grepl("^condition",di[j,k])) { conditionj <- as.character(di[j,k]); }
if (grepl("^list",di[j,k])) { listj <- as.character(di[j,k]); }
if (grepl("^((train)|(test))Trial",di[j,k])) { trialsj <- c(trialsj,as.character(di[j,k])); }
}
# make data frame for current row
mturkDataj <- data.frame(
ID=workerIdj,
sex=sexj,
acceptTime=acceptTimej,
submitTime=submitTimej,
condition=conditionj,
list=listj,
trials=trialsj );
# accumulate data across rows
if (is.null(mturkData)) { mturkData <- mturkDataj; }
else { mturkData <- rbind(mturkData,mturkDataj); }
}
}
mturkData$phase <- ifelse(grepl("trainTrial",mturkData$trial),"train","test");
test <- subset(mturkData, phase=="test");
test$trial <- sapply(as.character(test$trials), function(x) { strsplit(x,"_")[[1]][1] });
test$type <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][2] });
test$text <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][3] });
test$choice1 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][4] });
test$choice2 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][5] });
test$choice3 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][6] });
test$choice4 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][7] });
test$correctChoice <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][8] });
test$oldNew <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][9] });
test$response <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][10] });
test$choice <- test$response;
test$choice <- ifelse(	test$response=="radio5","1",
ifelse( test$response=="radio6","2",
ifelse( test$response=="radio7","3",
ifelse( test$response=="radio8","4",NA))));
test$condition <- NA
test[test$list %in% c("list_A_NumAdj","list_B_NumAdj"),]$condition <- "NAdjNum"
test[test$list %in% c("list_A_DemNum","list_B_DemNum"),]$condition <- "NNumDem"
test[test$list %in% c("list_A_DemAdj","list_B_DemAdj","list_A","list_B"),]$condition <- "NAdjDem"
stringToOrder <- function(string,inner,outer,nouns) {
words <- strsplit(string," ")
if (length(words[[1]])==2 || words=="-----") { order <- "twoWords"}
else {
if (words[[1]][1] %in% nouns) {
if (words[[1]][2] %in% inner) { order <- "NInnerOuter"}
else {order <- "NOuterInner"}
}
else {
if (words[[1]][1] %in% inner) { order <- "InnerOuterN"}
else {order <- "OuterInnerN"}
}
}
order
}
findLexicon <- function(data_row) {
# all possible lexical items
dems <- c("that","this","these","those");
nouns <-c("banana","box","chair","couch","dart","handbag","key","leaf","pear","pineapple",
"ribbon","shirt","shovel","suitcase","vase","bowl","car","cherry","cow","duck",
"hat","horse","lamp","pig","pillow","pitcher","scarf","shoe","spatula","tray",
"bananas","boxes","chairs","couches","darts","handbags","keys","leaves","pears",
"pineapples","ribbons","shirts","shovels","suitcases","vases","bowls","cars",
"cherries","cows","ducks","hats","horses","lamps","pigs","pillows","pitchers",
"scarves","shoes","spatulas","trays");
adjs <- c("purple","furry","spotted","wooden","green","orange","dirty","striped","stone","blue");
nums <- c("two","three","six","seven","nine","one","four","five","eight","ten");
# set default inner and outer
inner <- adjs;
outer <- dems;
# change if necessary based on condition
if (data_row$condition=="NNumDem") { inner <- nums; }
if (data_row$condition=="NAdjNum") { outer <- nums; }
lexicon <- list(nouns=nouns,inner=inner,outer=outer)
}
labelChoices <- function(data) {
data$choice1_order <- NA; data$choice2_order <- NA; data$choice3_order <- NA; data$choice4_order <- NA
data$choice_order <- NA
# loop over all rows in the data
# find lexicon, then output choice orders for each option
for (i in 1:nrow(data)) {
# find lexicon, including inner and outer modifiers for this row of data
lexicon = findLexicon(data[i,])
# split the words from each choice apart
data[i,]$choice1_order <- stringToOrder(data[i,]$choice1,lexicon$inner,lexicon$outer,lexicon$nouns)
data[i,]$choice2_order <- stringToOrder(data[i,]$choice2,lexicon$inner,lexicon$outer,lexicon$nouns)
data[i,]$choice3_order <- stringToOrder(data[i,]$choice3,lexicon$inner,lexicon$outer,lexicon$nouns)
data[i,]$choice4_order <- stringToOrder(data[i,]$choice4,lexicon$inner,lexicon$outer,lexicon$nouns)
}
# label the order of participant's response choice
data[data$choice=="1",]$choice_order <- data[data$choice=="1",]$choice1_order
data[data$choice=="2",]$choice_order <- data[data$choice=="2",]$choice2_order
data[data$choice=="3",]$choice_order <- data[data$choice=="3",]$choice3_order
data[data$choice=="4",]$choice_order <- data[data$choice=="4",]$choice4_order
# return the labelled dataframe
data
}
test = labelChoices(test)
test$binaryCorrect <- 0;
test[test$choice==test$correctChoice,]$binaryCorrect <- 1;
fixedAdjDem <- read.table("data/testDataBatch1FixedNew.txt",sep="\t",header=T)
test <- rbind(test,fixedAdjDem)
labelLexicalItems <- function(data) {
data$noun <- NA; data$inner <- NA; data$outer <- NA;
for (i in 1:nrow(data)) {
lexicon = findLexicon(data[i,])
words <- strsplit(data[i,]$choice1," ") # need to use choice1 rather than text, which misses some spaces (!)
data[i,]$noun <- words[[1]][which(words[[1]] %in% lexicon$nouns)]
if (length(words[[1]])==2) {
mods <- c(lexicon$inner,lexicon$outer)
data[i,]$inner <- words[[1]][which(words[[1]] %in% mods)]
}
else {
data[i,]$inner <- words[[1]][which(words[[1]] %in% lexicon$inner)]
data[i,]$outer <- words[[1]][which(words[[1]] %in% lexicon$outer)]
}
}
# change nouns into all singular forms
data$noun <- gsub("s$","",data$noun)
data$noun <- gsub("couche","couch",data$noun)
data$noun <- gsub("scarve","scarf",data$noun)
data$noun <- gsub("cherrie","cherry",data$noun)
data$noun <- gsub("boxe","box",data$noun)
data$noun <- gsub("leave","leaf",data$noun)
data
}
test <- labelLexicalItems(test)
write.table(test, file="U20English_TestData.csv",quote=F,sep=",")
test <- read.csv(file="U20English_TestData.csv",sep=",",header=T)
test.N = ddply(test, c("condition", "ID"), summarise, correct = mean(binaryCorrect))
ddply(test.N, c("condition"), summarise, N = length(correct))
test.single_mod <- subset(test, type %in% c("NAdj","NNum","NDem"))
test.two_mod <- subset(test, type %in% c("NAdjDem","NNumDem","NAdjNum"))
install.packages(plyr)
install.packages('plyr')
require('plyr')
test.single_mod <- subset(test, type %in% c("NAdj","NNum","NDem"))
test.two_mod <- subset(test, type %in% c("NAdjDem","NNumDem","NAdjNum"))
single_mod_correct <- ddply(test.single_mod, c("ID", "condition"), summarise, single_mod_correct = mean(binaryCorrect))
single_mod_correct
byparticipant = ddply(test.two_mod, c("condition", "ID"), summarise, isomorphic = mean(binaryCorrect))
summary = ddply(byparticipant, c("condition"), summarise, N = length(isomorphic), mean = mean(isomorphic), sd = sd(isomorphic))
summary$se = summary$sd/sqrt(summary$N) # This adds standard errors
summary$pretty_cond <- "{A,Dem}"
summary[summary$condition=="NNumDem",]$pretty_cond <- "{Num,Dem}"
summary[summary$condition=="NAdjNum",]$pretty_cond <- "{A,Num}"
summary$pretty_cond <- factor(summary$pretty_cond, levels=c("{A,Dem}","{Num,Dem}","{A,Num}"))
fill.colors=c(hcl(h = seq(150, 230, length = 3), c=45, l=75))
ggplot(summary, aes(x=pretty_cond, y=mean, fill=pretty_cond)) +
ylab("Proportion conforming choice") +
xlab("Phrase type") +
theme(legend.position="none") +
theme(axis.title.x = element_text(vjust = 0),axis.title.y = element_text(vjust = 0.4)) +
theme(axis.title.x = element_text(size=20),axis.text.x = element_text(size=18), axis.title.y = element_text(size=20), axis.text.y=element_text(size=20), strip.text.x = element_text(size = 20)) +
geom_bar(position=position_dodge(),stat="identity") +
geom_errorbar(aes(ymin=mean-se, ymax=mean+se),
width=.125,       # width of the error bar top and bottom lines
size=0.25,		#line cex for error bars
position=position_dodge(.9)) +
scale_fill_manual(values=fill.colors)	+
geom_hline(aes(yintercept=0.5),linetype="dashed",size=0.5)
require('ggplot')
require('ggplot2')
fill.colors=c(hcl(h = seq(150, 230, length = 3), c=45, l=75))
ggplot(summary, aes(x=pretty_cond, y=mean, fill=pretty_cond)) +
ylab("Proportion conforming choice") +
xlab("Phrase type") +
theme(legend.position="none") +
theme(axis.title.x = element_text(vjust = 0),axis.title.y = element_text(vjust = 0.4)) +
theme(axis.title.x = element_text(size=20),axis.text.x = element_text(size=18), axis.title.y = element_text(size=20), axis.text.y=element_text(size=20), strip.text.x = element_text(size = 20)) +
geom_bar(position=position_dodge(),stat="identity") +
geom_errorbar(aes(ymin=mean-se, ymax=mean+se),
width=.125,       # width of the error bar top and bottom lines
size=0.25,		#line cex for error bars
position=position_dodge(.9)) +
scale_fill_manual(values=fill.colors)	+
geom_hline(aes(yintercept=0.5),linetype="dashed",size=0.5)
library(MCMCglmm)
test$condition <- factor(test$condition)
contrasts(test$condition) <- contr.sum(3);
install.packages("MCMCglmm")
library(MCMCglmm)
test$condition <- factor(test$condition)
contrasts(test$condition) <- contr.sum(3);
prior = list(
G = list(
G1 = list(V=diag(1), nu=2),	# diag(n) where n = number of parameters varying by subject; nu = n+1
G2 = list(V=diag(1), nu=2)#,	# diag(m) where m = number of parameters varying by item; nu = m+1
),
R = list(V=(1/k)*(I+J), nu=(k-1), fix=1)	# as per MCMCglmm manual
);
fixed = binaryCorrect ~ 1;
random = ~ ID + noun;
testAdjDem <- droplevels(subset(test, condition=="NAdjDem"));
testNumDem <- droplevels(subset(test, condition=="NNumDem"));
testAdjNum <- droplevels(subset(test, condition=="NAdjNum"));
```
library(ggplot2)
install.packages('ggplot2')
library(ggplot2)
library(colorspace)
library(lme4)
install.packages('lme4')
library(ggplot2)
library(colorspace)
library(lme4)
library(plyr)
q()
??subset()
subset(d, d$nbMods==2)
list.files(path = '.')
setwd("~/Documents/Science/U20/POS/data/test")
d = read.csv('ENGtest.csv')
head(d)
subset(d, d$nbMods==2)
install.packages("rmarkdown")
library(ggplot2)
library(colorspace)
library(lme4)
library(plyr)
files <- list.files("data",pattern="*.txt",recursive=FALSE);
mturkData <- NULL;
for (fi in files) {
di <- read.csv(paste("data",fi,sep="/"), encoding="UTF-8", quote = "", header=FALSE);
ID <- NA;
sex <- NA;
condition <- NA;
trials <- c();
for (j in 1:ncol(di)) { # go through each column and look for relevant information
if (grepl("id",di[1,j])) { ID <- as.character(di[1,j]); }
if (grepl("^(fe|)male$",di[1,j])) { sex <- as.character(di[1,j]); }
if (grepl("^condition",di[1,j])) { condition <- as.character(di[1,j]); }
if (grepl("^((train)|(test))Trial",di[1,j])) { trials <- c(trials,as.character(di[1,j])); }
}
print(fi)
#print(ID)
#print(trials)
# make data frame for current file
mturkDataj <- data.frame(
ID=ID,
sex=sex,
condition=condition,
trials=trials );
# accumulate data across rows
if (is.null(mturkData)) { mturkData <- mturkDataj; }
else { mturkData <- rbind(mturkData,mturkDataj); }
}
mturkData$phase <- ifelse(grepl("trainTrial",mturkData$trial),"train","test");
test <- subset(mturkData, phase=="test");
# parse train and test trial information
test$trial <- sapply(as.character(test$trials), function(x) { strsplit(x,"_")[[1]][1] });
test$type <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][2] });
test$correctChoice <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][3] });
test$choice1 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][4] });
test$choice2 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][5] });
test$choice3 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][6] });
test$choice4 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][7] });
test$response <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][8] });
test$mod <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][9] });
test$mod <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][10] });
test$oldNoun <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][11] });
test$oldMod1 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][12] });
test$oldMod2 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][13] });
test$choiceType1 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][14] });
test$choiceType2 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][15] });
test$choiceType3 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][16] });
test$choiceType4 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][17] });
# map responses to the same format as correct choice
test$choice <- test$response;
test$choice <- ifelse(	test$response=="radio5","1",
ifelse( test$response=="radio6","2",
ifelse( test$response=="radio7","3",
ifelse( test$response=="radio8","4",NA))));
test$binaryCorrect <- 0;
test[test$choice==test$correctChoice,]$binaryCorrect <- 1;
test.N = ddply(test, c("condition", "ID"), summarise, correct = mean(binaryCorrect))
ddply(test.N, c("condition"), summarise, N = length(correct))
test.single_mod <- subset(test, type %in% c("outer","inner"))
test.two_mod <- subset(test, type=="inner-outer")
single_mod_correct <- ddply(test.single_mod, c("ID", "condition"), summarise, single_mod_correct = mean(binaryCorrect))
single_mod_correct
#test.two_mod <- subset(test.two_mod, ID!="id_Wed Apr 19 2017 13:29:48 GMT+0700 (SE Asia Standard Time)")
test.two_mod = merge(test.two_mod, single_mod_correct)
test.two_mod <- subset(test.two_mod, single_mod_correct>.75)
#test.two_mod <- subset(test.two_mod, ID!="id_Wed Apr 19 2017 13:29:48 GMT+0700 (SE Asia Standard Time)")
test.two_mod = merge(test.two_mod, single_mod_correct)
test.two_mod <- subset(test.two_mod, single_mod_correct>.85)
byparticipant = ddply(test.two_mod, c("condition", "ID"), summarise, isomorphic = mean(binaryCorrect))
summary = ddply(byparticipant, c("condition"), summarise, N = length(isomorphic), mean = mean(isomorphic), sd = sd(isomorphic))
summary$se = summary$sd/sqrt(summary$N) # This adds standard errors
summary$pretty_cond <- "{A,Dem}"
summary[summary$condition=="condition_NumDem",]$pretty_cond <- "{Num,Dem}"
summary[summary$condition=="condition_AdjNum",]$pretty_cond <- "{A,Num}"
summary$pretty_cond <- factor(summary$pretty_cond, levels=c("{A,Dem}","{Num,Dem}","{A,Num}"))
fill.colors=c(hcl(h = seq(150, 230, length = 3), c=45, l=75))
ggplot(summary, aes(x=pretty_cond, y=mean, fill=pretty_cond)) +
ylab("Proportion conforming choice") +
xlab("Phrase type") +
theme(legend.position="none") +
theme(axis.title.x = element_text(vjust = 0),axis.title.y = element_text(vjust = 0.4)) +
theme(axis.title.x = element_text(size=20),axis.text.x = element_text(size=18), axis.title.y = element_text(size=20), axis.text.y=element_text(size=20), strip.text.x = element_text(size = 20)) +
geom_bar(position=position_dodge(),stat="identity") +
geom_errorbar(aes(ymin=mean-se, ymax=mean+se),
width=.125,       # width of the error bar top and bottom lines
size=0.25,		#line cex for error bars
position=position_dodge(.9)) +
scale_fill_manual(values=fill.colors)	+
geom_hline(aes(yintercept=0.5),linetype="dashed",size=0.5)
test$binaryCorrect <- 0;
test[test$choice==test$correctChoice,]$binaryCorrect <- 1;
write.table(test, "U20Spanish_TestData.csv", quote=F, sep=',')
