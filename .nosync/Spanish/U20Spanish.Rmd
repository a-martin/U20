---
title: "U20 Spanish"
output:
  html_notebook: default
  html_document: default
---
## Preliminaries
```{r}
library(ggplot2)
library(colorspace)
library(lme4)
library(plyr)
```
## Read in the data
```{r}
files <- list.files("data",pattern="*.txt",recursive=FALSE);
mturkData <- NULL;

for (fi in files) {
di <- read.csv(paste("data",fi,sep="/"), encoding="UTF-8", quote = "", header=FALSE);
ID <- NA;
sex <- NA;
condition <- NA;
trials <- c();
for (j in 1:ncol(di)) { # go through each column and look for relevant information
	if (grepl("id",di[1,j])) { ID <- as.character(di[1,j]); }
	if (grepl("^(fe|)male$",di[1,j])) { sex <- as.character(di[1,j]); }
	if (grepl("^condition",di[1,j])) { condition <- as.character(di[1,j]); }
	if (grepl("^((train)|(test))Trial",di[1,j])) { trials <- c(trials,as.character(di[1,j])); }
}
print(fi)
#print(ID)
#print(trials)
# make data frame for current file
mturkDataj <- data.frame(
				ID=ID,
				sex=sex,
				condition=condition,
				trials=trials );
# accumulate data across rows
	if (is.null(mturkData)) { mturkData <- mturkDataj; }
else { mturkData <- rbind(mturkData,mturkDataj); }
}
```
Create a new column for training vs. testing phase, and then get just the testing lines
```{r}
mturkData$phase <- ifelse(grepl("trainTrial",mturkData$trial),"train","test");
test <- subset(mturkData, phase=="test");
```

Then need to parse the trials into parts, and code for training versus testing phase.
```{r}
# parse train and test trial information
test$trial <- sapply(as.character(test$trials), function(x) { strsplit(x,"_")[[1]][1] });
test$type <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][2] });
test$correctChoice <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][3] });
test$choice1 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][4] });
test$choice2 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][5] });
test$choice3 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][6] });
test$choice4 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][7] });
test$response <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][8] });
test$mod <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][9] });
test$mod <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][10] });
test$oldNoun <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][11] });
test$oldMod1 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][12] });
test$oldMod2 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][13] });
test$choiceType1 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][14] });
test$choiceType2 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][15] });
test$choiceType3 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][16] });
test$choiceType4 <- sapply(as.character(test$trials), function(x) { y <- strsplit(x,"_")[[1]][17] });
```
Then create a new column to read radio button responses as choices 1-4
```{r}
# map responses to the same format as correct choice
test$choice <- test$response;
test$choice <- ifelse(	test$response=="radio5","1",
					ifelse( test$response=="radio6","2",
					ifelse( test$response=="radio7","3",
					ifelse( test$response=="radio8","4",NA))));
```
Finally (for now), create a column for binary correct vs. incorrect.
```{r}
test$binaryCorrect <- 0;
test[test$choice==test$correctChoice,]$binaryCorrect <- 1;
write.table(test, "U20Spanish_TestData.csv", quote=F, sep=',')
```
### Analyse the data
Check how many participants we have in each condition:
```{r}
test.N = ddply(test, c("condition", "ID"), summarise, correct = mean(binaryCorrect))
ddply(test.N, c("condition"), summarise, N = length(correct))
```

First, separate into single, and two modifier trials for sanity check with the single modifier phrases:
```{r}
test.single_mod <- subset(test, type %in% c("outer","inner"))
test.two_mod <- subset(test, type=="inner-outer")
```
Accuracy on single modifier phrases:
```{r}
single_mod_correct <- ddply(test.single_mod, c("ID", "condition"), summarise, single_mod_correct = mean(binaryCorrect))
single_mod_correct
```
I'm going to exclude all the participants who didn't get 75% correct for the single_mod trials, because that seems like they really didn't get it... (AM: we should use .85 and be consistent across experiments)
```{r}
#test.two_mod <- subset(test.two_mod, ID!="id_Wed Apr 19 2017 13:29:48 GMT+0700 (SE Asia Standard Time)")
test.two_mod = merge(test.two_mod, single_mod_correct)
test.two_mod <- subset(test.two_mod, single_mod_correct>.85)
```
Create a by-participant summary structure, use that to create a by-condition summary with by-participant error bars.
```{r}
byparticipant = ddply(test.two_mod, c("condition", "ID"), summarise, isomorphic = mean(binaryCorrect))
summary = ddply(byparticipant, c("condition"), summarise, N = length(isomorphic), mean = mean(isomorphic), sd = sd(isomorphic))
summary$se = summary$sd/sqrt(summary$N) # This adds standard errors

```

Pretty up the labels:
```{r}
summary$pretty_cond <- "{A,Dem}"
summary[summary$condition=="condition_NumDem",]$pretty_cond <- "{Num,Dem}"
summary[summary$condition=="condition_AdjNum",]$pretty_cond <- "{A,Num}"
summary$pretty_cond <- factor(summary$pretty_cond, levels=c("{A,Dem}","{Num,Dem}","{A,Num}"))
```

Now, plot it
```{r, fig.width=5, fig.height=5}
fill.colors=c(hcl(h = seq(150, 230, length = 3), c=45, l=75))

ggplot(summary, aes(x=pretty_cond, y=mean, fill=pretty_cond)) + 
	ylab("Proportion conforming choice") +
	xlab("Phrase type") +
	theme(legend.position="none") +
	theme(axis.title.x = element_text(vjust = 0),axis.title.y = element_text(vjust = 0.4)) +
	theme(axis.title.x = element_text(size=20),axis.text.x = element_text(size=18), axis.title.y = element_text(size=20), axis.text.y=element_text(size=20), strip.text.x = element_text(size = 20)) +
	geom_bar(position=position_dodge(),stat="identity") +
	geom_errorbar(aes(ymin=mean-se, ymax=mean+se),
                  width=.125,       # width of the error bar top and bottom lines
                  size=0.25,		#line cex for error bars
                  position=position_dodge(.9)) +
	scale_fill_manual(values=fill.colors)	+
  geom_hline(aes(yintercept=0.5),linetype="dashed",size=0.5)

```
